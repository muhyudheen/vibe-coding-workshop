<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vibe Royale</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,#081229,#0b1b33);
      overflow:hidden;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Players */
    .player{
      position:absolute;
      width:40px;
      height:40px;
      line-height:40px;
      text-align:center;
      font-size:28px;
      user-select:none;
      transition: opacity 1s linear, transform 0.15s linear;
      will-change: transform, left, top;
      z-index: 2;
      pointer-events: none;
    }
    .player.out{
      opacity:0;
      transform: scale(0.6);
    }

    /* Storm */
    .storm{
      position: fixed;
      top: 50%;
      left: 50%;
      width: 300vw;   /* massive circle outside viewport */
      height: 300vh;
      border-radius: 50%;
      border: 50px solid rgba(255,30,30,0.18);
      background: transparent;
      transform: translate(-50%, -50%) scale(1);
      filter: blur(12px);
      box-shadow: 0 0 120px 30px rgba(255,20,20,0.12), inset 0 0 60px rgba(255,40,40,0.06);
      pointer-events: none;
      z-index: 1;
      animation: shrinkStorm 60s linear forwards;
    }

    @keyframes shrinkStorm {
      from { transform: translate(-50%, -50%) scale(1); }
      to   { transform: translate(-50%, -50%) scale(0); }
    }

    /* Winner overlay */
    #winner {
      position: fixed;
      inset: 0;
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
      z-index: 999;
      opacity:0;
      transition: opacity 0.6s ease;
    }
    #winner .card{
      text-align:center;
      color: white;
      text-shadow: 0 6px 30px rgba(0,0,0,0.6);
      font-size: clamp(28px, 6vw, 128px);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding: clamp(18px, 2vw, 48px);
      border-radius: 20px;
      backdrop-filter: blur(6px);
      display:inline-block;
      pointer-events:none;
    }
    #winner.show{ opacity: 1; }

    #winner .emoji { display:block; font-size: 1.4em; margin-bottom: 0.2em; }
    #winner .text { font-weight: 800; letter-spacing: 0.04em; font-size: 0.35em; }

    /* subtle hint */
    .hud{
      position: fixed;
      right: 12px;
      top: 10px;
      color: rgba(255,255,255,0.8);
      font-size: 13px;
      z-index: 1000;
      user-select:none;
      opacity:0.6;
    }
  </style>
</head>
<body>
  <div id="game"></div>
  <div class="storm" id="storm"></div>

  <div id="winner" role="status" aria-live="polite">
    <div class="card">
      <div class="emoji" id="winnerEmoji">ğŸ†</div>
      <div class="text">WINNER!</div>
    </div>
  </div>

  <div class="hud">Vibe Royale â€” Stay inside the storm</div>

  <script>
    // Step 1: The Players
    (function(){
      const EMOJI = [
        "ğŸ˜€","ğŸ˜…","ğŸ˜‚","ğŸ¤£","ğŸ˜Š","ğŸ˜","ğŸ˜","ğŸ˜œ","ğŸ¤©","ğŸ¤–",
        "ğŸ‘»","ğŸ’€","ğŸ¦Š","ğŸµ","ğŸ¦„","ğŸ™","ğŸ¢","ğŸ¦","ğŸ™","ğŸ€"
      ]; // 20 emojis (note: one repeated intentionally is ok, but here it's 20 items)
      const PLAYER_COUNT = 100;
      const PLAYER_SIZE = 40; // px
      const STEP = 6; // px per tick
      const gameEl = document.getElementById('game');
      const stormEl = document.getElementById('storm');

      // Create players
      const players = [];
      for(let i=0;i<PLAYER_COUNT;i++){
        const d = document.createElement('div');
        d.className = 'player';
        d.textContent = EMOJI[Math.floor(Math.random()*EMOJI.length)];
        // Random position inside viewport
        const x = Math.random()*(window.innerWidth - PLAYER_SIZE);
        const y = Math.random()*(window.innerHeight - PLAYER_SIZE);
        d.style.left = x + 'px';
        d.style.top  = y + 'px';
        gameEl.appendChild(d);
        players.push(d);
      }

      // Utility to get center point of an element
      function centerOf(el){
        const rect = el.getBoundingClientRect();
        return { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
      }

      // Step 3: Game Loop
      let loopId = null;
      function startGameLoop(){
        loopId = setInterval(gameTick, 100);
      }

      function gameTick(){
        // Move each player by a small random step if they're not already out
        for(const p of players){
          if(p.classList.contains('out')) continue;
          // random direction each tick
          const angle = Math.random()*Math.PI*2;
          const dx = Math.cos(angle) * STEP;
          const dy = Math.sin(angle) * STEP;
          // current position
          const currentLeft = parseFloat(p.style.left) || 0;
          const currentTop  = parseFloat(p.style.top)  || 0;
          let nx = currentLeft + dx;
          let ny = currentTop  + dy;
          // keep inside window bounds so they don't drift infinitely offscreen (optional)
          nx = Math.max(0, Math.min(window.innerWidth - PLAYER_SIZE, nx));
          ny = Math.max(0, Math.min(window.innerHeight - PLAYER_SIZE, ny));
          p.style.left = nx + 'px';
          p.style.top  = ny + 'px';
        }

        // Check storm bounds - compute current storm circle center and radius
        const stormRect = stormEl.getBoundingClientRect();
        const stormCenter = {
          x: stormRect.left + stormRect.width/2,
          y: stormRect.top + stormRect.height/2
        };
        const stormRadius = Math.min(stormRect.width, stormRect.height)/2;

        // Mark players outside the storm as 'out'
        for(const p of players){
          if(p.classList.contains('out')) continue;
          const c = centerOf(p);
          const dist = Math.hypot(c.x - stormCenter.x, c.y - stormCenter.y);
          // If distance is greater than the storm radius (consider border thickness), they're outside
          if(dist > stormRadius){
            p.classList.add('out');
          }
        }

        // Step 4: Check for winner
        const alive = players.filter(p => !p.classList.contains('out'));
        if(alive.length === 1){
          endGameWithWinner(alive[0]);
        }
        // If zero left (all out) also end but no emoji winner
        if(alive.length === 0){
          endGameWithWinner(null);
        }
      }

      // End the game and display winner
      function endGameWithWinner(winnerEl){
        if(loopId !== null){
          clearInterval(loopId);
          loopId = null;
        }
        // Stop the storm animation early by freezing its computed transform to the current state
        // (optional) But we can just leave it.
        const winnerDiv = document.getElementById('winner');
        const winnerEmoji = document.getElementById('winnerEmoji');
        if(winnerEl){
          winnerEmoji.textContent = winnerEl.textContent || 'ğŸ‰';
        } else {
          winnerEmoji.textContent = 'ğŸª¦';
        }
        // show big winner overlay
        winnerDiv.classList.add('show');
      }

      // Start game when ready
      window.addEventListener('load', () => {
        // Ensure storm animation restarts fresh if the page is reloaded
        // (animation defined in CSS already starts automatically)
        startGameLoop();
      });

      // Optional: pressing R restarts the page (quick dev convenience)
      window.addEventListener('keydown', (e) => {
        if(e.key === 'r' || e.key === 'R'){
          location.reload();
        }
      });

      // Make sure players reposition nicely on resize so they remain in viewport
      window.addEventListener('resize', () => {
        for(const p of players){
          const left = parseFloat(p.style.left) || 0;
          const top  = parseFloat(p.style.top)  || 0;
          const nx = Math.max(0, Math.min(window.innerWidth - PLAYER_SIZE, left));
          const ny = Math.max(0, Math.min(window.innerHeight - PLAYER_SIZE, top));
          p.style.left = nx + 'px';
          p.style.top  = ny + 'px';
        }
      });
    })();
  </script>
</body>
</html>
